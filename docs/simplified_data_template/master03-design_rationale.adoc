= Design Rationale

== Background

The information models of openEHR are structured in multiple layers, with the primary distinction being between an information model layer (the 'Reference Model' or RM), and domain-level models expressed in archetypes and templates, that latter of which expresses particular data sets. Each such data set is defined in terms of an {openehr_am_opt2}[openEHR Operational Template (OPT)^], derived from a source template, and ultimately particular archetypes, which are themselves constraint models based on the RM, i.e. the 'canonical model'.

The openEHR RM and supporting models (BASE component) are designed with two computational goals in mind:

1. **Self-standing data instances**: Healthcare data instances are fully defined and self-standing when shared with a data partner that does not use openEHR. All necessary context, structure, and semantics are embedded within the data itself.
2. **Regular, predictable software behaviour**: Software that implements the model works in regular, expected ways across all use cases. For example, the structure of the openEHR `OBSERVATION`, `HISTORY`, and `EVENT` classes will generically represent any observation, from a single weight measurement to 100,000 samples of complex vital signs data.

The model is accordingly rigorous and comprehensive, ensuring that:

* All clinical contexts are properly captured
* Data can be queried consistently
* Information models remain stable over time
* Systems can validate data against formal definitions


== Canonical Format

In the context of openEHR serialization, **"canonical"** means any fully expressed instance data in which:

* the containment structure follows that of the RM;
* all RM mandatory fields are present;
* all attributes are named as per the RM, and
* all cardinalities respect the RM.

The default serialised data representations for openEHR content are canonical XML, based on the {openehr_its_xml_releases}[openEHR RM XSDs^], canonical JSON, described by the {openehr_its_json_releases}[openEHR JSON schemas^], and potentially any other canonical serial format based on the underlying Reference Model (e.g. YAML).

The canonical formats are routinely used by all openEHR implementations implementing the {openehr_ehr_rest_api}[openEHR REST API specification^], and in other ways (e.g., for database dump/load implementation, ETL operations, system integration, etc.).

=== Canonical JSON Example

The following example shows a simple body temperature observation in canonical openEHR JSON format:

[source,json]
----
{
  "_type": "COMPOSITION",
  "name": {
    "_type": "DV_TEXT",
    "value": "Vital Signs"
  },
  "archetype_details": {
    "archetype_id": {
      "value": "openEHR-EHR-COMPOSITION.encounter.v1"
    },
    "template_id": {
      "value": "Vital Signs"
    },
    "rm_version": "1.0.4"
  },
  "language": {
    "_type": "CODE_PHRASE",
    "terminology_id": {
      "_type": "TERMINOLOGY_ID",
      "value": "ISO_639-1"
    },
    "code_string": "en"
  },
  "territory": {
    "_type": "CODE_PHRASE",
    "terminology_id": {
      "_type": "TERMINOLOGY_ID",
      "value": "ISO_3166-1"
    },
    "code_string": "US"
  },
  "category": {
    "_type": "DV_CODED_TEXT",
    "value": "event",
    "defining_code": {
      "_type": "CODE_PHRASE",
      "terminology_id": {
        "_type": "TERMINOLOGY_ID",
        "value": "openehr"
      },
      "code_string": "433"
    }
  },
  "composer": {
    "_type": "PARTY_IDENTIFIED",
    "name": "Dr. Smith"
  },
  "context": {
    "_type": "EVENT_CONTEXT",
    "start_time": {
      "_type": "DV_DATE_TIME",
      "value": "2024-01-15T10:30:00Z"
    },
    "setting": {
      "_type": "DV_CODED_TEXT",
      "value": "other care",
      "defining_code": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "openehr"
        },
        "code_string": "238"
      }
    }
  },
  "content": [
    {
      "_type": "OBSERVATION",
      "name": {
        "_type": "DV_TEXT",
        "value": "Body temperature"
      },
      "archetype_node_id": "openEHR-EHR-OBSERVATION.body_temperature.v1",
      "language": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "ISO_639-1"
        },
        "code_string": "en"
      },
      "encoding": {
        "_type": "CODE_PHRASE",
        "terminology_id": {
          "_type": "TERMINOLOGY_ID",
          "value": "IANA_character-sets"
        },
        "code_string": "UTF-8"
      },
      "subject": {
        "_type": "PARTY_SELF"
      },
      "data": {
        "_type": "HISTORY",
        "name": {
          "_type": "DV_TEXT",
          "value": "History"
        },
        "archetype_node_id": "at0002",
        "origin": {
          "_type": "DV_DATE_TIME",
          "value": "2024-01-15T10:30:00Z"
        },
        "events": [
          {
            "_type": "POINT_EVENT",
            "name": {
              "_type": "DV_TEXT",
              "value": "Any event"
            },
            "archetype_node_id": "at0003",
            "time": {
              "_type": "DV_DATE_TIME",
              "value": "2024-01-15T10:30:00Z"
            },
            "data": {
              "_type": "ITEM_TREE",
              "name": {
                "_type": "DV_TEXT",
                "value": "Tree"
              },
              "archetype_node_id": "at0001",
              "items": [
                {
                  "_type": "ELEMENT",
                  "name": {
                    "_type": "DV_TEXT",
                    "value": "Temperature"
                  },
                  "archetype_node_id": "at0004",
                  "value": {
                    "_type": "DV_QUANTITY",
                    "magnitude": 37.5,
                    "units": "Â°C"
                  }
                }
              ]
            }
          }
        ]
      }
    }
  ]
}
----


=== The Challenge

While canonical formats ensure data integrity and semantic interoperability, they present significant challenges:

1. __Steep learning curve__: Developers must understand the full openEHR Reference Model hierarchy, including classes like `HISTORY`, `ITEM_TREE`, `EVENT_CONTEXT`, etc.
2. __Verbose structures__: Even simple data requires extensive JSON/XML structure with many nested objects and mandatory fields.
3. __Type specifications__: Every object requires `_type` declarations, which adds to verbosity.
4. __Boilerplate repetition__: Many fields (like `name`, `language`, `encoding`) must be repeated throughout the structure even when they don't vary.

These challenges are particularly acute for developers working on:

* __Form-based applications__: Where templates define a fixed structure
* __Limited use cases__: Applications targeting specific clinical scenarios (vital signs, lab results, medication lists)
* __Integration projects__: Where external systems need to submit data to openEHR repositories

The starting point for defining a developer-friendly format is to recognise that the great majority of applications are typically targeted to one or a few specific data sets (e.g. vital signs monitoring, diabetic care management, pregnancy care plans). These applications don't need the full generality of the canonical format for every transaction.


== Historical Formats

Creating canonical data instances is not always straightforward, and various alternatives have been used in the past to simplify the job of content creation and committal for application developers. Template-specificity provides a route to simplification: each openEHR template can be used to define one or more reasonably simple commit formats.

The <<tds,Template Data Schema (TDS)>> format was originally devised by Ocean Health Systems as an XSD-based format. An XSLT script transformed `.oet` template source files and archetypes into a single XML Schema (XSD) for any given template. The transformation flattened various RM structures to make them simpler to understand and also converted archetype node codes (at-codes of Object nodes) to XSD tag names, e.g. 'serum_sodium'. This enabled developers to easily identify the XML Element for each data item they needed to populate to create a TDS instance document, known as a Template Data Document (TDD).

The <<ecisflat,ECISFLAT>> format was developed for the EtherCIS project as a JSON-based alternative. It uses AQL-style paths based on natural language-independent codes (like `at0001`) and, apart from simplification of `DV_XXX` and `PARTY_PROXY` types, largely retains the openEHR RM structure.

The <<better_web_template,Web Template (WT)>> serialisation format was developed by Better (formerly Marand). It represents a more radical simplification of the openEHR RM and BASE models, using programmer-friendly, natural language-based paths. The serialisation format was originally based on the TDS, with a concrete expression in JSON and using paths, rather than sparse XML.

EHRbase adopted and extended WT serialisation as <<ehrbase-sdt,Simplified Data Template (SDT)>> format.


== Simplified JSON Formats

The *SDT* format represents a more radical simplification of the openEHR RM and BASE models, using programmer-friendly, natural language-based paths. The format was originally based on TDS concepts but with:

* Concrete expression in JSON
* Human-readable path elements (e.g., `body_temperature`, `serum_sodium`)
* Two variants: **flat** (simSDT) and **structured** (structSDT)

Key innovations:

* Node IDs generated from human-readable names in any language
* Separation of context data (`ctx/` prefix)
* Elimination of intermediate RM structures (`ITEM_TREE`, `HISTORY`, etc.)
* Direct element-to-value mapping
* Optional RM attributes with an underscore prefix

Advantages:

* Highly readable, language-agnostic paths
* Minimal learning curve for developers
* Suitable for form-based applications
* Both flat and hierarchical representations are available

The format with its two variants is the basis for the current specification.

=== Example simSDT:

The simSDT format represents data in a flattened key-value structure where paths are used as keys, making it particularly suitable for form-based data entry and simple data structures.
All nested objects are flattened into a single level using path separators.

[source, json]
--------
{
  "laboratory_order/_uid": "23d69330-7790-4394-8abc-1455681f6ffa::ydh.code4health.com::1",
  "laboratory_order/language|code": "en",
  "laboratory_order/language|terminology": "ISO_639-1",
  "laboratory_order/territory|code": "GB",
  "laboratory_order/territory|terminology": "ISO_3166-1",
  "laboratory_order/context/_health_care_facility|id": "999999-345",
  "laboratory_order/context/_health_care_facility|id_scheme": "2.16.840.1.113883.2.1.4.3",
  "laboratory_order/context/_health_care_facility|id_namespace": "NHS-UK",
  "laboratory_order/context/_health_care_facility|name": "Northumbria Community NHS",
  "laboratory_order/context/setting|terminology": "openehr",
  "laboratory_order/laboratory_test_request/_uid": "b8c17799-457d-4583-8d85-c369dffacc21",
  "laboratory_order/laboratory_test_request/lab_request/service_requested|code": "444164000",
  "laboratory_order/laboratory_test_request/lab_request/service_requested|value": "Urea, electrolytes and creatinine measurement",
  "laboratory_order/laboratory_test_request/lab_request/service_requested|terminology": "SNOMED-CT",
  "laboratory_order/laboratory_test_request/lab_request/timing": "R5/2015-04-10T00:19:00+02:00/P2M",
  "laboratory_order/laboratory_test_request/lab_request/timing|formalism": "timing",
  "laboratory_order/laboratory_test_request/narrative": "Urea, electrolytes and creatinine measurement",
  "laboratory_order/laboratory_test_request/language|code": "en",
  "laboratory_order/laboratory_test_tracker/time": "2015-04-10T00:19:02.518+02:00",
  "laboratory_order/laboratory_test_tracker/language|code": "en",
  "laboratory_order/laboratory_test_tracker/language|terminology": "ISO_639-1",
  "laboratory_order/laboratory_test_tracker/encoding|code": "UTF-8",
  "laboratory_order/laboratory_test_tracker/encoding|terminology": "IANA_character-sets",
  "laboratory_order/composer|name": "Dr Joyce Smith",
  "ctx/language": "en",
  "ctx/territory": "GB"
}
--------

=== Example structSDT:

Another variant for this simplification is the _structSDT_ JSON format, with the difference that data is represented in JSON structures based on paths from the associated Web Template, rather than flattening them as a key-value list. An example is shown below.

[source, json]
--------
{
    "ctx": {
      "language": "en",
      "territory": "SI",
      "composer_name": "matijak_test"
    },
    "vitals": {
      "vitals": [
        {
          "body_temperature": [
            {
              "any_event": [
                {
                  "description_of_thermal_stress": [
                    "Test description of symptoms"
                  ],
                  "temperature": [
                    {
                      "|magnitude": 37.2,
                      "|unit": "Â°C"
                    }
                  ],
                  "symptoms": [
                    {
                      "|code": "at0.64",
                      "|value": "Chills / rigor / shivering",
                      "|terminology": "local"
                    }
                  ],
                  "time": [
                    "2014-01-22T15:18:07.339+01:00"
                  ]
                }
              ]
            }
          ]
        }
      ],
      "context": [
        {
          "setting": [
            {
              "|code": "238",
              "|value": "other care",
              "|terminology": "openehr"
            }
          ],
          "start_time": [
            "2014-01-22T15:18:07.339+01:00"
          ]
        }
      ]
    }
  }
--------


=== Requirements

To make any simplified format viable, the following requirements must be met:

1. **Abstraction capability**: The format makes it possible to abstract away rigorous structural complexity of the canonical model where appropriate, mainly by making the data less self-standing and relying more on a schema (the template).

2. **Machine generability**: The format definition for any given commit data can be completely and routinely machine-generated from its canonical definition (i.e. from an openEHR Operational Template).

3. **Bidirectional conversion**: Data instances of the simplified format can be routinely machine-converted to canonical format at execution time, and vice versa.

4. **Template specificity**: Field identifiers and structure are derived from and validated against a specific operational template.

5. **Preservation of semantics**: Despite simplification, all clinical semantics from the original archetype and template constraints are preserved.

These requirements ensure that the simplified format serves as a practical interface layer while maintaining the full rigour of openEHR at the persistence and interoperability layers.

NOTE: Developers using the simplified formats in example-based use cases do not need to understand the detailed conversion algorithms. Platforms based on openEHR typically provide services that generate example instances from templates and handle conversion transparently. The conversion details are primarily relevant for developers creating and maintaining openEHR platforms or dealing with complex integration scenarios.